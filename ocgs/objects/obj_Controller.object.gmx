<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create event

// initialize globals
global.selected = noone;
global.selectedXOffset = 0;
global.selectedYOffset = 0;

allCards = ds_list_create();

//filename = "";

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drag controller

    
if( global.selected != noone) {    
    with(global.selected) {
        x = mouse_x - global.selectedXOffset;
        y = mouse_y - global.selectedYOffset;
        depth = -1;
    }    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update depth list, deselect, update actual depths
        
//Move the selected card to the end of the list.
scr_moveto_end(allCards, global.selected);

//var idx = ds_list_find_index(allCards, global.selected);
//ds_list_delete(allCards, idx);
//ds_list_add(allCards, global.selected);

global.selected = noone;

// Update every card's depth to the inverse of its position.
// Then normalize so the closest card is at depth == 1
scr_update_depths();

/*
with(obj_card) {
    idx = ds_list_find_index(other.allCards, id);
    depth = -idx + ds_list_size(other.allCards);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="55">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Add a new card to the game &amp; depth list

inst_id = instance_create(mouse_x, mouse_y, obj_card);

with(inst_id) {    
    width = 63;
    height = 88;
    image_xscale = 2 * width/sprite_get_width(sprite_index);
    image_yscale = 2 * height/sprite_get_height(sprite_index);
}


ds_list_add(allCards, inst_id);
scr_update_depths();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Load cards from a .deck's XML file

// create obj_xml_importer to handle the importing
instance_create(0,0, obj_xml_importer);

/* Below moved to obj_xml_importer

// Get the player's .deck file. If they don't select anything, don't do the rest of this event.
var filepath = get_open_filename("Import a .deck file|*.deck","");
if(filepath == "") exit;

// Unzip/"move" the data to the working dir. If there's an error, don't do the rest of this event.
var num = zip_unzip(filepath, "tmp/" );
if( num &lt;= 0) exit;

// Convert the file's contents to a string.
var file = file_text_open_read(working_directory + "tmp/info.xml");
var xml  = "";
while (!file_text_eof(file))
{
    xml += file_text_readln(file);
}
file_text_close(file);

//type: xf_node
var root = xf_read_xml(xml);    // Parse the xml data.
var type;                       // e.g. "&lt;global&gt;, &lt;card&gt;"
var attrib;                     // e.g. "&lt;img&gt;, &lt;height&gt;, &lt;back&gt;"
var value;                      // e.g. "88, image.jpg" but it's still a node (not string) until xf_write_xml is used.

// type: sprite
var sharedFront = noone;
var sharedBack = noone;

// type: real
var sharedWidth = 0;
var sharedHeight = 0;

// Find all the GLOBALs to set up shared values.
for(i = 0; i &lt; xf_size(root); i++ ) {
    type = xf_get_child(root, i);
    if( xf_get_value(type) == "GLOBAL") {        
        for(j = 0; j &lt; xf_size(type); j++ ) {
            attrib = xf_get_child(type, j);
            value = xf_get_child(attrib, 0);
            
            if( ( xf_get_value(attrib) == "img") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                sharedFront = sprite_add(working_directory + "tmp/" + xf_write_xml(value), 0, false, false, 0, 0);
                
            if( ( xf_get_value(attrib) == "back") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                sharedBack = sprite_add(working_directory + "tmp/" + xf_write_xml(value), 0, false, false, 0, 0);
                
            if( (xf_get_value(attrib) == "height") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                sharedHeight = real(xf_write_xml(value));
                    
            if( ( xf_get_value(attrib) == "width") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                sharedWidth = real(xf_write_xml(value));
        }        
    }
}

show_debug_message("front: " + sprite_get_name(sharedFront) + " back: " + sprite_get_name(sharedBack) + " width: " + string(sharedWidth) + " height: " + string(sharedHeight) );


// Create a deck, and fill it with each card.
var deck = instance_create(mouse_x, mouse_y, obj_deck);
var copies = 0;

for(i = 0; i &lt; xf_size(root); i++) {
    type = xf_get_child(root, i);
    if( xf_get_value(type) == "card")
    {
        copies = xf_get_attr(type, "copies");      // Get the number of copies of the card
        if(copies == -4 ) {                         // If copies isn't listed, it only wants one.
            copies = 1;
        }        
        for(j = 0; j &lt; copies; j++) {
            with( instance_create(x, y, obj_card) ) {
            
                // Set to the shared values first, so if they are never overwidden the shared value will be used.
                front = sharedFront;
                back = sharedBack;
                width = sharedWidth;
                height = sharedHeight;
                
                for(j = 0; j &lt; xf_size(type); j++ ) {
                    attrib = xf_get_child(type, j);
                    value = xf_get_child(attrib, 0);
                    
                    if( ( xf_get_value(attrib) == "img") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                        front = sprite_add(working_directory + "tmp/" + xf_write_xml(value), 0, false, false, 0, 0);
                        
                    if( ( xf_get_value(attrib) == "back") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                        back = sprite_add(working_directory + "tmp/" + xf_write_xml(value), 0, false, false, 0, 0);
                        
                    if( (xf_get_value(attrib) == "height") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                        height = real(xf_write_xml(value));
                            
                    if( ( xf_get_value(attrib) == "width") &amp;&amp; (xf_get_type(value) == xf_type_text) )
                        width = real(xf_write_xml(value));
                }
                
                // Set up the sprite/scale/origin for the card, add the card to the deck, and set the deck's depth
                
                sprite_index = front;
                sprite_set_offset(sprite_index, (sprite_width / 2), (sprite_height / 2) );
                image_xscale = 2 * width/sprite_get_width(sprite_index);
                image_yscale = 2 * height/sprite_get_height(sprite_index);
                
                ds_list_add(deck.list, id);
                deck.depth = 0;
                
                // Deactivate the card so it doesn't exist on its own while in a deck.
                instance_deactivate_object(id);                
            }
        }
    }
}

// Once everything has been loaded, get rid of the files from the temporary directory.
var delFileName = file_find_first(working_directory + "tmp\*.*", 0);
var delPath = working_directory + "tmp\" + delFileName;
while(delFileName != "") {
    file_delete(delPath);
    delFileName = file_find_next();
    delPath = working_directory + "tmp\" + delFileName;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pick up the closest card under the cursor.

// Finds the obj_movable (card or deck) under the cursor with the lowest depth.
// returns noone if nothing is found.

var object = scr_find_movable(mouse_x, mouse_y);


// Check to make sure we did find something.
if(object != noone) {
    if(object.object_index == obj_card)
        scr_select_card(object);
    else if (object.object_index == obj_deck)     // what we found was a deck.
        scr_draw_from_deck(object); // Draw a card!    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INACTIVE
/*

var testString = ""

var i_d = ds_map_find_value(async_load, "id");
if i_d == msg
   {
   if ds_map_find_value(async_load, "status")
      {
      if ds_map_find_value(async_load, "result") != ""
         {
         testString = ds_map_find_value(async_load, "result");
         }
      }
   }
   
show_debug_message(testString);

//
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
