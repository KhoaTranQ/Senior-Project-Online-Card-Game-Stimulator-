<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-3</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set up formatting and populate with cards

//global&gt;&gt;&gt;view = id;

list = ds_list_create();


//face_up = true;
flip_all = false;

// Using a "trick" we were able to send a reference to a deck
// and the desired number of cards for the view in place of x and y coords
// We could have sent a data structure with as many args as we want
// But our real coords are based on the decks, so this was all we needed.
deck = x;
num = min(y, ds_list_size(deck.list));
reverse = 0;

per_row = 4;
num_rows = 3;

//Currently assumes all cards in the deck will be the same dimensions as the top card
item_width = global.scale * ds_map_find_value(deck.list[| 0], "width");
item_height = global.scale * ds_map_find_value(deck.list[| 0], "height");

nav = 25;

margin = 10;
padding = 5;

width = (2*margin) + per_row*(item_width + padding) - padding;
height = (2*margin) + num_rows*(item_height + padding) - padding;

x = deck.x - width/2;
y = deck.y - height/2;

/*
** Make sure the view stays on screen as much as possible.
*/
if(x + width + nav &gt; view_xview[0] + view_wview[0])
{
    x = view_xview[0] + view_wview[0] - width - nav;
}

if(x - nav &lt; view_xview[0])
{
    x = view_xview[0] + nav;
}

if( y + height + nav &gt; view_yview[0] + view_hview[0])
{
    y = view_yview[0] + view_hview[0] - height - nav;
}

if(y - nav &lt; view_yview[0])
{
    y = view_yview[0] + nav;
}

x1 = x - nav;
y1 = y - nav;
x2 = x + width + nav;
y2 = y + height + nav;

per_page = per_row * num_rows;

num_pages = ceil(num / per_page);

curr_page = 0;

deck.view = id;

scr_view_update(id);
sync_view_open(deck, num);
//scr_update_depths();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//global.&gt;&gt;&gt;view = noone;

for(i = 0; i &lt; ds_list_size(list); i++)
{
    with(list[| i])
    {
        instance_destroy();
    }
    
}

deck.view = noone;

ds_list_destroy(list);

sync_view_close(deck);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the view's UI

//Main area
draw_set_color(c_ltgray);
draw_rectangle(x, y, x+width, y+height, false);

//Left and right navigation
draw_set_color(c_gray);
draw_rectangle(x1, y, x, y2, false);
draw_rectangle(x+width, y, x2, y2, false);

draw_sprite_ext(spr_navArrow, 0, x1 + (nav/2), y+(height+nav)/2, -1, 1, 0, c_white, 1);
draw_sprite(spr_navArrow, 0, x+width+(nav/2), y+(height+nav)/2);


//Top and bottom
draw_set_color(c_dkgray);
draw_rectangle(x1, y1, x2, y, false);
draw_rectangle(x, y+height, x+width, y2, false);

draw_sprite(spr_flip, 0, x+width/2, y + height + (nav/2));

//Close
draw_set_color(c_red);
draw_rectangle(x2-nav, y1, x2, y, false);

draw_sprite(spr_exit, 0, x+width + (nav/2), y - (nav/2));

/*
**  Draw "after bottom of deck" seperator
**
**  page that will be incomplete: num div per_page
**  number of cards on that page: num mod per_page
**
**  row of last card: last_card div per_row
**  column of last card: last_card mod per_row
**
**  "last page" is the last page for cards in the FRONT of the deck,
**  not the last page for all cards.
*/

draw_set_color(c_red);

var last_page = num div per_page;
var last_card = num mod per_page;

var row = last_card div per_row;
var column = last_card mod per_row;

if(curr_page = last_page)
{   //We're on the last page
    row = last_card div per_row;
    column = last_card mod per_row;
    
    if(column == 0)
    {   //There are no partial rows
        if(last_card != 0)
        {   //  But there are cards
            //  draw seperator at the end of the row,
            //  instead of the beginning of the next
            left = x + margin + per_row*(item_width+padding) - padding;
            top = y + margin + (row-1)*(item_height+padding);  
            draw_rectangle(left, top, left+padding, top+item_height, false);
        }
        else
        {   //  There are no partial rows, because there's no cards
            //  Draw the seperator normally, at the beginning of the first row
            left = x + margin + column*(item_width+padding) - padding;
            top = y + margin + row*(item_height+padding);  
            draw_rectangle(left, top, left+padding, top+item_height, false);
        }
    }
    else
    {   //  There are partial rows
        left = x + margin + column*(item_width+padding) - padding;
        top = y + margin + row*(item_height+padding);  
        draw_rectangle(left, top, left+padding, top+item_height, false);
    }
}
else if(last_card == 0 &amp;&amp; curr_page = last_page - 1)
{   //  The last page is full, and because of that the true last page
    //  is one sooner than previously calculated.
    //  If we're on that page, draw a seperator at the end of the last row.
    left = x + margin + (per_row)*(item_width+padding) - padding;
    top = y + margin + (num_rows-1)*(item_height+padding);
    
    draw_rectangle(left, top, left+padding, top+item_height, false);
}
else
{
    //  Not the last page in any respect.
    //  Don't draw anything.
}

/*
I could put a single draw_rectangle() at the end,
and but "exit" satements where it's not supposed to draw anything

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Turn to the next page

scr_view_next();

/*
curr_page = min(curr_page + 1, num_pages - 1);

scr_view_update(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Turn to the previous page

curr_page = max(0, curr_page - 1);

scr_view_update(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
