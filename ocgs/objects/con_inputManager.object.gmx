<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init vars

enum zone
{
    main = 64,
    hand = 65,
    view = 66,
    none = 67
}

global.input_object = id;

// initialize globals
selected = noone;

marked = noone;
multi = ds_list_create();

old_x = 0;
old_y = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up global list

ds_list_destroy(global.freeCards);
ds_list_destroy(global.handCards);
ds_list_destroy(global.searchCards);

with(obj_card) {
    sprite_delete(sprite_index);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drag controller

if(selected != noone)
{    image_blend = c_aqua;//blender
    switch(selected.object_index)
    {
        case obj_card:
            // card is in multi-select
            if( ds_list_find_index(multi, selected) &gt;= 0 )
            {
                for(var i = 0; i &lt; ds_list_size(multi); ++i)
                {
                    scr_move(multi[| i]);
                    sync_pos(multi[| i]);
                }
            }
            else if( selected.group != noone )
            {
                debug("Card is in a group");
            }
            else
            {
                scr_move(selected);
                sync_pos(selected);
            }
            
            //debug("My depth is: " + string(selected.depth));
            
            break;
            
        case obj_gizmo:
            // deck is in multi-select
            if( ds_list_find_index(multi, selected.deck) &gt;= 0 )
            {
                for(var i = 0; i &lt; ds_list_size(multi); ++i)
                {
                    scr_move(multi[| i]);
                    sync_pos(multi[| i]);
                }
            }
            else
            {
                scr_move(selected.deck);
                sync_pos(selected.deck);
            }
            break;
            
        case obj_deck:
            //deck is in multi-select
            if( ds_list_find_index(multi, selected) &gt;= 0 )
            {
                for(var i = 0; i &lt; ds_list_size(multi); ++i)
                {
                    scr_move(multi[| i]);
                    sync_pos(multi[| i]);
                }
            }
            else
            {
                scr_move(selected);
                sync_pos(selected);
            }
            break;
            /*
        case obj_view:
            scr_move(selected);
            with(selected)
            {            
                x1 = x - nav;
                y1 = y - nav;
                x2 = x + width + nav;
                y2 = y + height + nav;
            }
            break;
            */
    }
}// End noone check

old_x = mouse_x;
old_y = mouse_y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drag controller for object that have following objects

if(selected != noone)
{
    switch(selected.object_index)
    {
        case obj_deck:
            break;
         
        case obj_view:
            scr_move(selected);
            scr_view_update(selected, false);
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drop selected

// Update depth list
// Deselect
// update actual depths
// insert into hand
// drop onto deck

if(selected != noone) {    
    var sel_type = selected.object_index;

    switch(sel_type)
    {
        case obj_card:
            //Move the selected card to the end of the list.
            
            selected.sel = false;
            scr_moveto_end(global.freeCards, selected);
           
            var object = scr_find_droppable(selected.x, selected.y);
            var obj_type = noone;
            if(object != noone)
            {
            
                obj_type = object.object_index;
              
            }
            
            switch(obj_type)
            {
            
                case obj_hand:
                  
                    if( ds_list_find_index(multi, selected) &gt;= 0 ) 
                    {
                        for(var i = 0; i &lt; ds_list_size(multi); i++)
                        {
                            if(multi[| i].object_index == obj_card)
                            {
                                scr_hand_insert(multi[| i]);
                                sync_hand_insert(multi[| i]);
                            }
                        }
                    }
                    else
                    {
                        scr_hand_insert(selected);
                        sync_hand_insert(selected);
                    }                   
                    scr_deselect_multi();
                    break;
                
                case obj_deck:
                    if( ds_list_find_index(multi, selected) &gt;= 0 )
                    {
                        for(i = 0; i &lt; ds_list_size(multi); i++)
                        {
                            multi[| i].image_blend = c_white;
                            if(multi[| i].object_index == obj_card)
                            {
                                sync_place(multi[| i]);
                                sync_deck_drop(object, multi[| i]);
                                scr_drop_on_deck(object, multi[| i]);
                            }
                        }
                        ds_list_clear(multi);
                    }
                    else
                    {
                        sync_place(selected);
                        sync_deck_drop(object, selected);
                        scr_drop_on_deck(object, selected);
                    }
                    //scr_deselect_multi();
                
                
                    //Be sure to run special placement code
                    //scr_drop_on_deck will destroy the card.
                    // This has to run first, and should clear the card from the syncMap.
                    
                    //This is now handeled in obj_card's "destroy" event.
                    //ds_list_delete(global.freeCards, ds_list_find_index(global.freeCards, selected));
                    break;
                    
                case obj_view:
                    if( ds_list_find_index(multi, selected) &gt;= 0)
                    {
                        var xCoord = selected.x;
                        var yCoord = selected.y;
                        for(i = 0; i &lt; ds_list_size(multi); i++)
                        {
                            multi[| i].image_blend = c_white;
                            if(multi[| i].object_index = obj_card)
                            {
                                sync_place(multi[| i]);
                                scr_view_insert(object, xCoord, yCoord, multi[| i]);
                            }
                        }
                        ds_list_clear(multi);
                    }
                    else
                    {
                        sync_place(selected);
                        scr_view_insert(object, selected.x, selected.y, selected);
                    }
                    break;
                    
                default:
                    if( ds_list_find_index(multi, selected) &gt;= 0)
                    {
                        var curr = noone;
                        for(var i = 0; i &lt; ds_list_size(multi); ++i)
                        {
                            curr = multi[| i];
                            //sync_pos(multi[| i]);
                            if(curr.object_index = obj_card)
                                sync_place(curr);
                        }
                    }
                    else
                    {
                        //sync_pos(selected);
                        sync_place(selected);
                    }
                    break;
            }
            break;
            
        case obj_deck:  // we were moving a deck.
            selected.depth = 0;
           
            
            if( ds_list_find_index(multi, selected) &gt;= 0)
            {
                for(var i = 0; i &lt; ds_list_size(multi); ++i)
                {
                    //sync_pos(multi[| i]);
                    //sync_place(multi[| i]);
                }
            }
            else
            {
                //sync_pos(selected);
                //sync_place(selected);
            }
            break;
    }    
    selected = noone;
}



// Update every card's depth to the inverse of its position.
// Then normalize so the closest card is at depth == 1
scr_update_depths();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create the context menu.

//Find the object we clicked on. This will become the drop down menu's "context".
var object = scr_find_clickable(mouse_x, mouse_y);

// Use the constructor method to ensure the object gets everything it needs
// without having to put half its code in a with(){} construction.

new(obj_context_menu, scr_norm_x(mouse_x), scr_norm_y(mouse_y), object);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pick up the closest card under the cursor.

// Finds the par_clickable (card or deck) under the cursor that is on top.
// returns noone if nothing is found.

//if( !scr_menu_overlap() ) {
    var object = scr_find_clickable(mouse_x, mouse_y);
    var type = noone;    
    if(object != noone)
    {  
        type = object.object_index;
    }
    
    switch(type) {
        case obj_card:
            var pos = scr_multi_find(object);
            
            if( !scr_zone_view(object) &amp;&amp; keyboard_check(vk_shift) )
            {
                if( pos &lt; 0 )
                {
                    ds_list_add(multi, object);
                    object.image_blend = c_aqua;
                }
                else
                {
                    ds_list_delete(multi, pos);
                    object.image_blend = c_white;
                }
            }
            else
            {
                if( pos &lt; 0 )
                {
                    scr_deselect_multi();
                }
                
                scr_select(object);
            }
            break;
            
        case obj_deck:
            var pos = scr_multi_find(object);
            
            if( keyboard_check(vk_shift) )
            {
                if( pos &lt; 0 )
                { // not already in multi
                    ds_list_add(multi, object);
                    object.image_blend = c_aqua;
                }
                else
                {
                    ds_list_delete(multi, pos);
                    object.image_blend = c_white;
                }
            }
            else
            {
                scr_deselect_multi();
                scr_select(scr_draw_from_deck(object));
            }
            break;
            
        case obj_gizmo:
            var pos = scr_multi_find(object.deck);
        
            if( keyboard_check(vk_shift) )
            {
                if( pos &lt; 0 )
                {
                    ds_list_add(multi, object.deck);
                    object.deck.image_blend = c_aqua;
                }
                else
                {
                    ds_list_delete(multi, pos);
                    object.deck.image_blend = c_white;
                }
            }
            else
            {
                if(pos &lt; 0)
                {
                    scr_deselect_multi();
                }
                scr_select(object);
            }
            break;
            
        case obj_view:
            scr_view_select(object);
            //scr_select(object);
            break;
            
        case obj_log:
            scr_log_select(object);
            break;
            
        default:
            scr_deselect_multi();
            instance_create(mouse_x, mouse_y, obj_box_select);            
            break;
    }
    
    for (i = 0; i &lt; ds_list_size(multi); i++)
    {
    image_blend = c_aqua;//blender
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Insert a test deck

scr_create_test_deck();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drag controller
/*
**  Description
**      Keeps the selected object on-screen, even if it is rotated.
**
*/


if( selected != noone) {
    with(selected) {
       
        // Where the card would be moved if we weren't keeping it in bounds.
        var new_x = mouse_x - other.selectedXOffset;
        var new_y = mouse_y - other.selectedYOffset;
    
        // The distance from the edge of the card's BOUNDING BOX to its origin (center).
        // Using the bounding box is important for rotated objects.
        var hors_dist = ceil((bbox_right - bbox_left)/2);
        var vert_dist = ceil((bbox_bottom - bbox_top)/2);
        
        // The limits to the coordinates.
        var left_limit = view_xview[0] + hors_dist;
        var top_limit = view_yview[0] + vert_dist;
        
        x = max(left_limit, new_x);
        y = max(top_limit, new_y);
        
        
        
        /*  LEGACY 
        **  Removed: 2016-04-17 00:44
        ** 
        **  Reason
        **      Allowing the card to go below the bottom or right of the screen
        **      may be accetable due to a new resizing method.
        **
        **
        
        
        var right_limit = view_xview[0] + view_wview[0] - hors_dist;
        var bottom_limit = view_yview[0] + view_hview[0] - vert_dist;
    
        // the never let the coordinate get below or above the limits.
        // if new_x is below left_limit, x will be set to left_limit instead, etc.
        x = min( max(left_limit, new_x),
        right_limit );
         
        y = min( max(top_limit, new_y), 
        bottom_limit );
        */
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.multiplayer)
{
    global.multiplayer = false;
    with(global.net_object)
    {
        if(isServer)
            network_destroy(server);
        else
            network_destroy(socket);
    }
}

if( background_exists(background_index[0]) )
{
    background_delete(background_index[0]);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="88">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move a card to the top of the marked deck

if(marked != noone &amp;&amp; instance_exists(marked) )
{
    var object = scr_find_clickable(mouse_x, mouse_y);
    var type = scr_type(object);
    
    switch(type)
    {
        case obj_card:
            if(keyboard_check(vk_shift))
            {
                scr_flip_card(object);
                sync_flip(object);
            }
            
            var view_ = scr_view_find(object);
            if( scr_zone_hand(object) )
            {
                object.last_zone = zone.hand;
                var pos = ds_list_find_index(global.handCards, object);
                ds_list_delete(global.handCards, pos);
                sync_place(object);
            }
            else if( view_ != noone )
            {
                object.last_zone = zone.view;
                scr_view_remove(view_, object);
                sync_place(object);
            }
            sync_deck_drop(marked, object);
            scr_drop_on_deck(marked, object);
            break;
            
        case obj_deck:
            var card = scr_draw_from_deck(object)
            sync_deck_drop(marked, card);
            scr_drop_on_deck(marked, card);
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="86">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create a view panel for this deck

var object = scr_find_clickable(mouse_x, mouse_y);
var type = scr_type(object);

switch(type)
{
    case obj_gizmo:
        object = object.deck;
    case obj_deck:
        if(object.view == noone)
        {
            //new(async_view_manager, object, false);
            new(obj_view, object, ds_list_size(object.list) );
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="84">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// TURN the object (card or deck) by 90 degrees ANTI-clockwise.

var object = noone;
var type = noone;
var amt = 45;

if( selected == noone) {
    object = scr_find_clickable(mouse_x, mouse_y);
}
else {
    object = selected;
}

if(object != noone)
{
    type = object.object_index;
}

switch type
{
    case obj_card:
        scr_rotate(object, amt);
        sync_rotate(object, amt);
        break;
        
    case obj_deck:
        scr_rotate(object, amt);
        sync_rotate(object, amt);
        break;
        
    case obj_gizmo:
        scr_rotate(object.deck, amt);
        sync_rotate(object.deck, amt);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///SHUFFLE a deck

var object = noone;

// Prioritize a selected object.
if(selected == noone)
{
    object = scr_find_clickable(mouse_x, mouse_y);
}
else
{
    object = selected;
}

var type = scr_type(object);

switch(type)
{
    case obj_gizmo:
        object = object.deck;
    case obj_deck:
        var code = scr_rep_shuffle(object.list);
        sync_shuffle(object, code);
        scr_view_update(object.view);
        break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ROTATE the object (card or deck) CLOCKWISE.

var amt = 45;

var object = noone;

if( selected == noone) {
    object = scr_find_clickable(mouse_x, mouse_y);
}
else {
    object = selected;    
}

type = noone;
if(object != noone)
    type = object.object_index;
    
switch(type)
{
    case obj_card:
        scr_rotate(object, -amt);
        sync_rotate(object, -amt);
        break;
        
    case obj_deck:
        scr_rotate(object, -amt);
        sync_rotate(object, -amt);
        break;
        
    case obj_gizmo:
        scr_rotate(object.deck, -amt);
        sync_rotate(object.deck, -amt);
        break;
    default:
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MARK a deck

var object = scr_find_clickable(mouse_x, mouse_y);

var type = noone;
if(object != noone)
{
    type = object.object_index;
}

switch(type)
{
    case obj_gizmo:
        object = object.deck;
    case obj_deck:
        marked = object;
        debug("DECK WAS MARKED!");
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///move to HAND a card from the deck below the cursor

var object = noone;

if(selected == noone)
{
    object = scr_find_clickable(mouse_x, mouse_y);
}
else
{
    object = selected;
    selected = noone;
}

var type = scr_type(object);

switch(type)
{
    case obj_card:
        if( !scr_zone_hand(object) )
        {
            var view_ = scr_view_find(object)
            if( view_ != noone )
            {
                scr_view_remove(view_, object);
                sync_place(object);
            }
                
            scr_hand_insert(object, true);
            sync_hand_insert(object);
        }
        break;
        
    case obj_gizmo:
        object = object.deck;
    case obj_deck:
        var card = scr_draw_from_deck(object)
        scr_hand_insert(card, true);
        sync_hand_insert(card);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// FLIPS the selected card, or the card under the cursor that is closest. &gt;con_inputManager press_F

// Normally the selected card should always be the closest under the cursor, but
// if the cursor is moved fast enough, it's possible for it to go outside of the bounds
// of the selected card.
// But this will garantee if a card is selected, it will always be the one flipped.

var object = noone;
var type = noone;

if(selected == noone)
{
    object = scr_find_clickable(mouse_x, mouse_y);
}
else
{
    object = selected;
}

if(object != noone)
{
    type = object.object_index;
}

switch type
{
    case obj_card:
        scr_flip_card(object);
        sync_flip(object);
        break;
        
    case obj_deck:
    scr_flip_deck(object);
    sync_flip(object);
        break;
        
    default:
        break;
}
/*


if(selected != noone)
{
    if(selected.object_index = obj_card) {        
        scr_flip_card(selected);
        sync_flip(selected);
    }
    else if( selected.object_index = obj_deck) {
        scr_flip_deck(selected)
        sync_flip(selected);
    }
}
else
{
    var object =  scr_find_clickable(mouse_x, mouse_y);
    
    if(object != noone) {
        if(object.object_index = obj_card) {        
            scr_flip_card(object);
            sync_flip(object);
        }
        else if( object.object_index = obj_deck) {
            scr_flip_deck(object)
            sync_flip(object);
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DRAW from marked deck

if(marked != noone &amp;&amp; instance_exists(marked) )
{
    var card = scr_draw_from_deck(marked)
    scr_hand_insert(card, true);
    
    sync_hand_insert(card);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="67">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONVERT a free card to a single-card deck

//var object = noone;

var object = scr_find_clickable(mouse_x, mouse_y)

// Make sure we're not trying to turn the selected object into a deck.
if( selected != object )
{
    var type = noone;
    
    if(object != noone)
    {
        type = object.object_index;
    }
    
    switch(type)
    {
        // make sure it's a crd.
        case obj_card:
            // Make sure it's not in a special zone.
            if( scr_zone_free(object) )
            {
                // Get the object's network ID while it still exists.
                var obj_net_id = object.net_id;
                var deck = scr_card_to_deck(object);
                sync_card_to_deck(obj_net_id, deck);
            }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="46">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// delete a card or deck

var object = noone;

if( selected == noone) {
    object = scr_find_clickable(mouse_x, mouse_y);
}
else {
    object = selected;   
    selected = noone;
}


if(object != noone)
{
    scr_delete(object);
}

/*
var type = scr_type(object);

switch(type)
{
    case obj_gizmo:
        object = object.deck;
        
    case obj_card:
    case obj_deck:    
        scr_deselect_multi();
    
        sync_delete(object);
        with(object)
        {
            instance_destroy();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="36">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Bring card to front

var object = scr_find_clickable(mouse_x, mouse_y);
var type = noone;

if(object != noone)
{
    type = object.object_index;
}

switch(type)
{
    case obj_card:
        if( scr_zone_free(object) )
        {
            sync_depthcmd(object, 0);
            scr_moveto_end(global.freeCards, object);
            scr_update_depths();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="35">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Send card to back

var object = scr_find_clickable(mouse_x, mouse_y);
var type = noone;

if(object != noone)
{
    type = object.object_index;
}

switch(type)
{
    case obj_card:
        if( scr_zone_free(object) )
        {
            sync_depthcmd(object, 1);
            scr_moveto_start(global.freeCards, object);
            scr_update_depths();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="34">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move behind next closest

/* Need rectangle/rectangle intersection that doesn't rely on bboxes for this.
var object = scr_find_clickable(mouse_x, mouse_y);
var type = noone;

if(object != noone) {
    type = object.object_index;
}

switch(type)
{
    case obj_card:
        if(scr_zone_free(object))
        {
            
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Zoom into current card &gt;con_inputManager press_&lt;alt&gt;


var object = scr_find_clickable(mouse_x, mouse_y)

if( object != noone ) {
    if(object.object_index == obj_card) {
        new(obj_zoom, object);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
