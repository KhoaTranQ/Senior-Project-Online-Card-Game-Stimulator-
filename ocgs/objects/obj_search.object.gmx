<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// &gt;obj_search create and notes


// Personal Notes on Bottom //

list = ds_list_create();

depth = -3;



searchHeight = 75;

spacing = 45;

x1 = view_xview[0] + spacing;
y1 = view_hview[0] - (searchHeight / 2);

x2 = x1 + (searchHeight * 5)
y2 = y1 + searchHeight;



padding = 10;
margin = 10;

deck = x;// The x coord doesnt matter for this object
x = 0;// Just set it to zero for visual ease


searchCards = ds_list_create();// creates a data sttructure called searchCards

var size = ds_list_size(deck.list); // variable "size" is now the size of the deck list
var card = noone;
scroll = 5; //maximum card that should be displayed
descroll = 0; //counter and deletion for cards

//loop for all cards for (i = 0; i &lt; size; i++) 
for (descroll = scroll - 5; descroll  &lt; scroll; descroll++)  //
 
{
    card = scr_card_from_map(ds_list_find_value(deck.list, descroll) ); // new is scr_card from map
    
    ds_list_add(global.searchCards, card); // adds the card to the ds list: searchCards

}

larrow = sprite_add("spr_larrow.sprite", 1, true, true, 325, 250);  //not working, either of these
rarrow = sprite_add("spr_arrow", 1, true, true, 325, 400);

 if(descroll = scroll) //reset descroll - not effective
    {
    descroll = descroll -5;
    
    }
    
scr_update_depths();
    
    
/*  
    Things accomplished:
        Edited the list to a global list called "global.searchCards" and seems to work as it has.
        Cards now populate in the searchbox rather than the hand
        Cards now resize correctly
        Got the view to display 5 cards only, working on +5 interval
            to interval, would i need to redo the loop entirely in the right pressed event?
                or perhaps moved to STEP??
        made another arrow, reusing arrows of dropdown menu for this searchbox - still working on
        proper view formatting
        Cards now delete properly when the search is exited (new key is ESCAPE)
        
                //card.depth = 
                // will have to be global
                //scr_update depth
                //search box closer than hand
                //cards closer than panel
                //searchbox = -3
                //cards = -3.5 - -4.5

        
        
    Working on
        This shit needs a code cleanup...
        Got the view to display 5 cards only, working on +5 interval
            to interval, would i need to redo the loop entirely in the right pressed event?
        
        
    Error reports:
        When a resized card is placed on the original deck, the game crashes with an error.
            perhaps this can be fixed by using a throw exception of some sort?
        Deleting a card from the search is fine, however, deleting two brings an error. - crash
        Hitting view deck again adds 5 more cards to the searchbox --  something that does not allow it to be selected again???
        Cards are not updating their depths until clicked (click where you know the card is behind the silver search box)
        Error with updating depths when search is selected from dropdown again - crash
*/


    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keeps cards that are supposed to be in the search, in the search. &gt;obj_search step


var size = ds_list_size(global.searchCards);

for(i = 0; i &lt; size; i++ ) {
    var card = global.searchCards[| i];

    with( card ) {
        
        // Rescale to card to fit into the search if it cannot already.
        // sprite_height takes image_scale into acount, so after changing those,
        // this code shouldn't get run again unless something else changes, like if it's flipped.
        // "20" is the total whitespace above and below the card.
        if( global.scale * height &gt; (other.searchHeight - 20) ) {
        
            // The algorithm for determining a card's new scale is &lt;desired&gt; / &lt;full_res&gt;
            // The desired width is based on the card's height and aspect ratio (AR).
            // width = height * AR; AR = width/height
            image_yscale = (other.searchHeight - 20)/sprite_get_height(card.sprite_index);       // sprite_get_height gets it unsclaed. sprite_height gets it after scaling     
            image_xscale = ( sprite_height * width/height )/sprite_get_width(card.sprite_index)
        }
        // The "if" here is to prevent the code from running if it doesn't have to.
        else if(sprite_height != global.scale * height || sprite_width != global.scale * width)
        {
            image_yscale = global.scale * height/sprite_get_height(card.sprite_index);
            image_xscale = global.scale * width/sprite_get_width(card.sprite_index);
        }
     
        // (1) Check if there's overflow.
        if( ((2 * other.margin) + sprite_width) + ((size-1)*(sprite_width + other.padding)-other.padding) + other.x1 &lt; other.x2 ) {
            // (2) No overflow, populate from the lfet.
            x = other.x1 + other.margin + (sprite_width / 2) + other.i*(sprite_width + other.padding);
        }
        else { // (3) Overflow, spread the cards evenly.
            x = other.x1 + other.margin + (sprite_width / 2) + other.i*( ((other.x2 - other.x1) -  (2 * (other.margin) + sprite_width) ) / (size - 1) );
        }
        
        y = (other.y1) + ((other.searchHeight - sprite_height) / 2) + (sprite_height / 2);  // (4)
                
    }
}

/*************************************************
Formatting is always hard to explain...

Padding: Space between cards.
Margin: Space between the search's edge and a card.

Notes:
(x1, y1) is the top left corner.
(x2, y2) is the bottom left corner.

x1 is the distance between the left edge and where the box starts.
x2 is the distance between the left edge and where the box ends.

y1 is where the top of the box is.
y2 is where the bottom of the box is.

x2 - x1 is the length of the box.
y2 - y1 is the height of the box (searchHeight)

Remember, multiplication comes before addition/subtraction!
I would add more parenthesis, but then it's just look cluttered instead. Even more, I mean.

(1): Overflow check.

"2 * margin" acounts for the margin to the left and right
the first " + sprite_width" acounts for the card's "overhang". Remember card positions are relative to their origin,
and our origins are in the centers of the cards. This means half the card overhangs the left, and half overhangs the right.

"(size-1)*(sprite_width + padding) - padding" is the space all the cards take up, including the card's width and padding.
Remember the rightmost card doesn't have more padding---only a margin, which has already been acounted for!
That's why one padding is subtracted.

And remember to add x1 in

(2): When there aren't enough cards to overflow.    
    The first card (i=0) will be right next to the margin. However remember the card's origin is in the center,
    so it's edge would be sprite_width/2 closer to the left than it's position (overhang). This is acounted for by adding it back.
    Also remember the box isn't against the edge of the room, so add x1 in
    When i=0, the third part "other.i*(...)" is zero. So the first card (index 0) will always be in the same spot.
    
    other.i*(sprite_width + other.padding) the space between each card, including card width and padding.
    
(3): There are enough cards to overflow. 
    The first card is in the same place---view_xview+margin+(sprite_width/2). other.i = 0, so other.i*(...) = 0.
    For the rest of the cards, first compute how much space there is. x2-x1 is all we have to work with.
    Of that, the margins on the left and right, and the card width (total overhang), are already taken.
    Divide that by the number of cards we have to get how far apart each card will have to be.
    
    When on the last card, i = size-1, so i/(size-1) = 1.
    This means that no matter how many cards there are, as long as there is overflow,
    the last card is always at exactly "x2 - margin - sprite_width/2",
    which is basically the same as the first card, but flipped.
    The card's right edge will be the margin away from the view's right edge.
    
    I had to get out a pen and paper to figure some of this out.
    
(4): Positioning the card vertically in the search.
    y1 is where the search starts (vertically).
    Get's the searchHeight subtracted by the card's height to find the total whitepace.
    Divides that whitespace by 2, to get the whitespace for the top and bottom.
    The card will need to be put the top whitespace's length away from the top of the search.
    Also acount for the card's centralized origin (there's vertical overhang too!)---add sprite_height/2.

I've had to come back and edit this a couple times. I tried to make the concept I call overhang clearer, for example.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// destroy instance


instance_destroy();
with(global.searchCards)instance_destroy();
ds_list_clear(global.searchCards);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///obj_hand draw

draw_set_color(c_silver);
draw_rectangle(x1, y1, x2, y2, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    scroll = scroll +5; //gives scroll 5 more - attempt to interval
    descroll = scroll -5; // resets min part of deck seeing - words

    ds_list_clear(global.searchCards);

for (descroll = scroll - 5; descroll  &lt; scroll; descroll++)  //
 
{
    card = scr_card_from_map(ds_list_find_value(deck.list, descroll) ); // new is scr_card from map
    
    ds_list_add(global.searchCards, card); // adds the card to the ds list: searchCards
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
