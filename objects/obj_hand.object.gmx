<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initilize variables

global.hand_object = id;

list = ds_list_create();

depth = -1;

// These are "normalized" sizes, i.e.,
// it's how large they should appear on the final screen.
padding_norm = 25;
margin_norm = 25;
top_margin_norm = 10;

// But with all the view code, we'll need to find what that distance translates to.
padding = 0;
margin = 0;
top_margin = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// obj_hand destroy

ds_list_destroy(global.handCards);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_hand</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keeps cards that are supposed to be in the hand, in the hand. &gt;obj_hand step


var size = ds_list_size(global.handCards);
//var view_hview[1] = view_hview[1];

for(i = 0; i &lt; size; i++ ) {
    var card = global.handCards[| i];
    
    // Find the values to keep the hand from scaling wildly in response to view changes.
    top_margin = scr_denorm_y(scr_norm_y(view_yview[1],1)+top_margin_norm,1) - view_yview[1];
    padding = scr_denorm_x(scr_norm_x(view_xview[1], 1) + padding_norm, 1) - view_xview[1];
    margin = scr_denorm_x(scr_norm_x(view_xview[1], 1) + margin_norm, 1) - view_xview[1];

    with( card ) {
        
        // Scale the card to hand-size.        
        // The algorithm for determining a card's new scale is &lt;desired&gt; / &lt;full_res&gt;
        // The desired width is based on the card's height and aspect ratio (AR).
        // width = height * AR; AR = width/height
        image_yscale = (view_hview[1] - (other.top_margin*2))/sprite_get_height(card.sprite_index);            
        image_xscale = (sprite_height * width/height)/sprite_get_width(card.sprite_index)
            
            
        // (1) Check if there's overflow.
        if( ((2 * other.margin) + sprite_width) + ((size-1)*(sprite_width + other.padding)-other.padding) &lt; view_wview[1] ) {
            x = view_xview[1] + other.margin + (sprite_width / 2) + other.i*(sprite_width + other.padding); // (2) No overflow, populate from the lfet.
            x = view_xview[0] + other.margin + (sprite_width / 2) + other.i*(sprite_width + other.padding);
        }
        else { // (3) Overflow, spread the cards evenly.
            x = view_xview[1] + other.margin + (sprite_width / 2) + other.i*( (view_wview[1] -  (2 * (other.margin) + sprite_width) ) / (size - 1) );
        }
        
        y = (view_yview[1]) + ((view_hview[1] - sprite_height) / 2) + (sprite_height / 2);  // (4)
                
    }
}

/*************************************************
---
Edit
    2016-14-17 09:57PM

Cards in the hand are now always the same size, and they always have the same spacing on the screen.
    
I've changed how certain formatting variables work.

now padding, margin, and the new top_margin have "normalized" (norm) and non-norm versions.

The norm versions are sizes based on the FINAL, OUTPUT TO THE SCREEN.

the non-norm versions translate that to in-game distances.

the non-norm versions need to be updated every time the view changes.
So for now I have them updating every step.
---
Edit
    2016-04-17 01:44AM
    
I've changed up how the hand works. Now a lot of the below may be inaccurate.

Basically "handHeight" is now "view_hview[1]".
---

Formatting is always hard to explain...

Padding: Space between cards.
Margin: Space between the hand's edge and a card.

Notes:

view_xview is where the view starts.
view_wview is how wide the view is.
Therefor view_xview + view_wview is where the view ends.

Remember, multiplication comes before addition/subtraction!
I would add more parenthesis, but then it's just look cluttered instead. Even more, I mean.

(1): Overflow check.

"2 * margin" acounts for the margin to the left and right
the first " + sprite_width" acounts for the card's "overhang". Remember card positions are relative to their origin,
and our origins are in the center of the cards. This means half the card overhands the left, and half overhangs the right.

"(size-1)*(sprite_width + padding) - padding" The space all the cards take up, including the card's width and padding.
Remember the rightmost card doesn't have more padding---only a margin, which has already been acounted for!
That's why one padding is subtracted.

(2): When there aren't enough cards to overflow.    
    The first card (i=0) will be right next to the margin. However remember the card's origin is in the center,
    so it's edge would be sprite_width/2 closer to the left than it's position (overhang). This is acounted for by adding it back.
    Also remember the view might not be against the edge of the room, so add it in (if it IS the left edgs of the room, it's 0).
    When i=0, the third part "other.i*(...)" is zero. So the first card (index 0) will always be in the same spot.
    
    other.i*(sprite_width + other.padding) the space between each card, including card width and padding.
    
(3): There are enough cards to overflow. 
    The first card is in the same place---view_xview+margin+(sprite_width/2). other.i = 0, so other.i*(...) = 0.
    For the rest of the cards, first computer how much space there is. view_wview is all we have to work with.
    Of that, the margins on the left and right, and the card width (overhang), are already taken.
    Divide that by the number of cards we have to get how far apart each card will have to be.
    
    When on the last card, i = size-1, so i/(size-1) = 1.
    This means that no matter how many cards there are, as long as there is overflow,
    the last card is always at exactly "view_xview + view_wview - margin - sprite_width/2",
    which is basically the same as the first card, but flipped.
    The card's right edge will be the margin away from the view's right edge.
    
    I had to get out a pen and paper to figure some of this out.
    
(4): Positioning the card vertically in the hand.
    view_yview+view_hview-handHeight is where the hand starts (vertically).
    Get's the handHeight subtracted by the card's height to find the total whitepace.
    Divides that whitespace by 2, to get the whitespace for the top and bottom.
    The card will need to be put the top whitespace's length away from the top of the hand.
    Also acount for the card's centralized origin (there's vertical overhang too!)---add sprite_height/2.

I've had to come back and edit this a couple times. I tried to make the concept I call overhang clearer, for example.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="55">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (disabled) Add a test card to the hand.
/*
inst_id = instance_create(0, 0, obj_card);

var sprite = noone;
var back = noone;


with(inst_id) {
    width = 63;
    height = 88
    scale = 2;
    var rand = choose(0, 1);
    
    if(rand == 0) { // liliana        
        var sprite = sprite_duplicate(spr_liliana);
        var back = sprite_duplicate(spr_back);
        sprite_merge(sprite, back);
        sprite_delete(back);
    }
    else {  // villager/werewolf
    
        var sprite = sprite_duplicate(spr_villager);
        var back = sprite_duplicate(spr_werewolf);
        sprite_merge(sprite, back);
        sprite_delete(back);
    }
    
    offset_x = sprite_get_width(sprite) / 2;
    offset_y = sprite_get_height(sprite) / 2;
    
    scale_x = width / sprite_get_width(sprite);
    scale_y = height / sprite_get_height(sprite);
    
    sprite_index = sprite;
    image_xscale = scale * scale_x;
    image_yscale = scale * scale_y;
    sprite_set_offset(sprite_index, offset_x, offset_y );
    
}


ds_list_add(global.handCards, inst_id);

scr_update_depths();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///obj_hand draw

draw_set_color(c_white);
//draw_rectangle(view_xview[1], view_yview[1] + view_hview[1], view_xview[1] + view_wview[0], view_yview[0] + view_hview[0], false);
draw_rectangle(view_xview[1], view_yview[1], view_xview[1] + view_wview[1], view_yview[1] + view_hview[1], false);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
